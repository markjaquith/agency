#!/usr/bin/env bun

import { execSync } from "child_process"
import { readFileSync } from "fs"
import { join } from "path"

// Regex to validate changeset frontmatter format
// Must have package name with bump type (e.g., "@markjaquith/agency": minor)
const frontmatterRegex = /^---\n([\s\S]*?)\n---\n/
const packageBumpRegex = /"([^"]+)"\s*:\s*(major|minor|patch)/

// Read the expected package name from package.json
function getExpectedPackageName(): string {
	const packageJsonPath = join(
		execSync("git rev-parse --show-toplevel", {
			encoding: "utf-8",
			stdio: ["pipe", "pipe", "pipe"],
		}).trim(),
		"package.json",
	)
	try {
		const packageJson = JSON.parse(readFileSync(packageJsonPath, "utf-8"))
		return packageJson.name
	} catch (error) {
		throw new Error(
			`Could not read package.json: ${error instanceof Error ? error.message : String(error)}`,
		)
	}
}

function validateChangesetFile(
	filePath: string,
	expectedPackageName: string,
): {
	valid: boolean
	error?: string
} {
	try {
		const content = readFileSync(filePath, "utf-8")

		// Check for frontmatter
		const frontmatterMatch = content.match(frontmatterRegex)
		if (!frontmatterMatch) {
			return { valid: false, error: "Missing or invalid frontmatter" }
		}

		const frontmatter = frontmatterMatch[1]

		// Check for package bump declaration and extract package name
		const packageMatch = frontmatter.match(packageBumpRegex)
		if (!packageMatch) {
			return {
				valid: false,
				error: `Missing package bump declaration (e.g., "${expectedPackageName}": minor)`,
			}
		}

		// Validate package name matches package.json
		const packageName = packageMatch[1]
		if (packageName !== expectedPackageName) {
			return {
				valid: false,
				error: `Package name "${packageName}" does not match expected "${expectedPackageName}"`,
			}
		}

		// Check for content after frontmatter
		const contentAfterFrontmatter = content
			.slice(frontmatterMatch[0].length)
			.trim()
		if (!contentAfterFrontmatter) {
			return { valid: false, error: "Missing changeset description" }
		}

		return { valid: true }
	} catch (error) {
		return {
			valid: false,
			error: `Could not read file: ${error instanceof Error ? error.message : String(error)}`,
		}
	}
}

try {
	// Check if branch has diverged from origin/main
	let commitCount: number
	try {
		const output = execSync("git rev-list --count origin/main..HEAD", {
			encoding: "utf-8",
			stdio: ["pipe", "pipe", "pipe"],
		})
		commitCount = parseInt(output.trim(), 10)
	} catch {
		// If origin/main doesn't exist, no divergence check needed
		process.exit(0)
	}

	// If no divergence, no changeset needed
	if (commitCount === 0) {
		process.exit(0)
	}

	// Branch has diverged - check for new changeset files
	let changesetFiles: string[]
	try {
		const output = execSync(
			"git diff --name-only --diff-filter=A origin/main..HEAD",
			{
				encoding: "utf-8",
				stdio: ["pipe", "pipe", "pipe"],
			},
		)
		// Filter for .changeset/*.md files (excluding README.md)
		changesetFiles = output
			.trim()
			.split("\n")
			.filter(
				(file) =>
					file.startsWith(".changeset/") &&
					file.endsWith(".md") &&
					file !== ".changeset/README.md",
			)
	} catch {
		changesetFiles = []
	}

	if (changesetFiles.length === 0) {
		console.error("❌ This branch requires a changeset file")
		process.exit(1)
	}

	// Validate each changeset file format
	const gitRoot = execSync("git rev-parse --show-toplevel", {
		encoding: "utf-8",
		stdio: ["pipe", "pipe", "pipe"],
	}).trim()

	const expectedPackageName = getExpectedPackageName()

	for (const file of changesetFiles) {
		const filePath = join(gitRoot, file)
		const result = validateChangesetFile(filePath, expectedPackageName)
		if (!result.valid) {
			console.error(`❌ Invalid changeset file format in ${file}`)
			console.error(`   ${result.error}`)
			process.exit(1)
		}
	}

	process.exit(0)
} catch (error) {
	if (error instanceof Error) {
		console.error(error.message)
	}
	process.exit(1)
}
